# import User,Institution,Course, CourseOrderByInput, UserOrderByInput, InstitutionOrderByInput, DepartmentOrderByInput, TestOrderByInput, PanelOrderByInput, QuestionOrderByInput, QuestionChoice, ChallengeOrderByInput, AnswerOrderByInput, Test, Question, QuestionChoice, Challenge, Answer,Sequence from "./generated/prisma.graphql"

directive @isAuthenticated on QUERY | FIELD_DEFINITION  | MUTATION
directive @hasRole(roles: [String]) on QUERY | FIELD_DEFINITION  | MUTATION
directive @isOwner(type: String) on QUERY | FIELD_DEFINITION  | MUTATION

type Query {

  institutions(filter: String, skip: Int, first: Int, orderBy: InstitutionOrderByInput): InstitutionSearch! @isAuthenticated
  courses(filter: String, skip: Int, first: Int, orderBy: CourseOrderByInput): CourseSearch! @isAuthenticated
  users(filter: String, skip: Int, first: Int, orderBy: UserOrderByInput): UserSearch! @isAuthenticated
  departments(filter: String, skip: Int, first: Int, orderBy: DepartmentOrderByInput): DepartmentSearch! @isAuthenticated
  tests(filter: String, skip: Int, first: Int, orderBy: TestOrderByInput): TestSearch! @isAuthenticated
  panels(filter: String, skip: Int, first: Int, orderBy: PanelOrderByInput): PanelSearch! @isAuthenticated
  questions(filter: String, skip: Int, first: Int, orderBy: QuestionOrderByInput): QuestionSearch! @isAuthenticated
  questionPercentCorrect(questionId: String): PercentCorrect!
  questionchoices(filter: String, skip: Int, first: Int, orderBy: QuestionChoiceOrderByInput): QuestionChoiceSearch! @isAuthenticated
  challenges(filter: String, skip: Int, first: Int, orderBy: ChallengeOrderByInput): ChallengeSearch! @isAuthenticated
  answers(filter: String, skip: Int, first: Int, orderBy: AnswerOrderByInput): AnswerSearch! @isAuthenticated
  sequences(filter: String): [Sequence!]! @isAuthenticated

  me: User
}

type Mutation {

  signup(email: String!, password: String!, firstName: String!,lastName: String!, role: String): AuthPayload

  login(email: String!, password: String!): AuthPayload

  addInstitution(name: String!, type: String, contactIds: ID, teacherIds: [ID], studentIds: [ID], courseIds: [ID]): Institution ! @hasRole(roles: ["QUANDRIA"])

  updateInstitution(id: ID!, name: String, type: String, contactIds: [ID], teacherIds: [ID], studentIds: [ID], courseIds: [ID]): Institution! @hasRole(roles: ["QUANDRIA"])

  deleteInstitution(id: ID!): Institution! @hasRole(roles: ["QUANDRIA"])

  addDepartment(name: String!, type: String, institutionId: ID!): Department @hasRole(roles: ["ADMIN"])

  updateDepartment(id: ID!, name: String, type: String, adminIds:[ID], teacherIds: [ID], courseIds: [ID], adminIds: [ID]): Department @hasRole(roles: ["ADMIN"])

  deleteDepartment(id: ID!): Department! @hasRole(roles: ["ADMIN"])

  addCourse(name: String!, courseNumber: String, time: String, institutionId: ID!, departmentId: ID): Course! @hasRole(roles: ["TEACHER","ADMIN"])

  updateCourse(id: ID!, name: String, courseNumber: String, time: String, teacherIds: [ID], studentIds: [ID]): Course! @hasRole(roles: ["TEACHER","ADMIN"])

  deleteCourse(id: ID!): Course! @hasRole(roles: ["TEACHER","ADMIN"])

  addTest(subject: String!, testNumber: String, testDate: DateTime, courseId: ID!): Test! @hasRole(roles: ["TEACHER","ADMIN"])

  updateTest(id: ID!, subject: String!, testNumber: String, testDate: DateTime, published: Boolean, publishDate: DateTime, release: Boolean, releaseDate: DateTime): Test! @hasRole(roles: ["TEACHER","ADMIN"])

  deleteTest(id: ID!): Test! @hasRole(roles: ["TEACHER","ADMIN"])

  addPanel(link: String!, testId: ID!): Panel! @hasRole(roles: ["TEACHER","ADMIN"])

  deletePanel(id: ID!): Panel! @hasRole(roles: ["TEACHER","ADMIN"])

  addQuestion(question: String!, testId: ID!, panelId: ID!, sentToId: ID!): Question! @hasRole(roles: ["TEACHER","STUDENT","ADMIN"])

  updateQuestion(id: ID!, question: String!, sentToId: ID): Question! @hasRole(roles: ["STUDENT"])

  deleteQuestion(id: ID!): Question! @hasRole(roles: ["TEACHER","STUDENT","ADMIN"])

  addQuestionChoice(choice: String!, correct: Boolean, questionId: ID!): QuestionChoice! @hasRole(roles: ["STUDENT"])

  updateQuestionChoice(id: ID!, choice: String, correct: Boolean): QuestionChoice! @hasRole(roles: ["STUDENT"])

  deleteQuestionChoice(id: ID!): QuestionChoice! @hasRole(roles: ["STUDENT"])

  addChallenge(challenge: String!, questionId: ID!): Challenge! @hasRole(roles: ["TEACHER","STUDENT","ADMIN"])

  updateChallenge(id: ID!, challenge: String!): Challenge! @hasRole(roles: ["TEACHER","STUDENT","ADMIN"])

  deleteChallenge(id: ID!): Challenge! @hasRole(roles: ["TEACHER","STUDENT","ADMIN"])

  addAnswer(questionId: ID!, answerChoiceId: ID!): Answer! @hasRole(roles: ["STUDENT"])

  deleteAnswer(id: ID!): Answer! @hasRole(roles: ["STUDENT"])

  addSequence(testId: ID!, studentIds: [ID!]!, panelIds: [ID!]!): Sequence!

  updateSequence(id: ID!, studentIds: [ID], usedStudentIds: [ID], panelIds: [ID], usedPanelIds: [ID]): Sequence!

  deleteSequence(id: ID!): Sequence!

  updateUser(email: String,
  salutation: String,
  firstName: String,
  lastName: String,
  studentInstitutionIds: [ID],
  teacherInstitutionIds: [ID],
  adminInstitutionIds: [ID],
  teacherDepartmentIds: [ID],
  studentDepartmentIds: [ID],
  adminDepartmentIds: [ID],
  studentIds:[String],
  teacherIds: [String],
  phone: String,
  online: Boolean): User! @isAuthenticated

}

type UserSearch {
  users: [User!]!
  count: Int!
  fullName: String!
}

type CourseSearch {
  courses: [Course!]!
  count: Int!
}

type InstitutionSearch {
  institutions: [Institution!]!
  count: Int!
}

type DepartmentSearch {
  departments: [Department!]!
  count: Int!
}

type TestSearch {
  tests: [Test!]!
  count: Int!
}

type PanelSearch {
  panels: [Panel!]!
  count: Int!
}

type QuestionSearch {
  questions: [Question!]!
  count: Int!
}

type PercentCorrect {
  total: Int!
  totalCorrect: Int!
  percentCorrect: Float!
}

type QuestionChoiceSearch {
  questionchoices: [QuestionChoice!]!
  count: Int!
}

type ChallengeSearch {
  challenges: [Challenge!]!
  count: Int!
}

type AnswerSearch {
  answers: [Answer!]!
  count: Int!
}

type AuthPayload {
  token: String
  user: User
}
