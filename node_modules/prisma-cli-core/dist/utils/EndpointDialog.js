"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var inquirer = require("inquirer");
var chalk_1 = require("chalk");
var prisma_yml_1 = require("prisma-yml");
var util_1 = require("../util");
var sillyname = require("sillyname");
var path = require("path");
var fs = require("fs");
var prisma_db_introspection_1 = require("prisma-db-introspection");
var yaml = require("js-yaml");
var encodeMap = {
    'prisma-eu1': 'sandbox-eu1',
    'prisma-us1': 'sandbox-us1',
};
var decodeMap = {
    'sandbox-eu1': 'prisma-eu1',
    'sandbox-us1': 'prisma-us1',
};
var defaultPorts = {
    postgres: 5432,
    mysql: 3306,
};
var databaseServiceDefinitions = {
    postgres: "\n  db:\n    image: postgres\n    restart: always\n    environment:\n      POSTGRES_USER: prisma\n      POSTGRES_PASSWORD: prisma\n",
    mysql: "\n  db:\n    image: mysql:5.7\n    restart: always\n    environment:\n      MYSQL_ROOT_PASSWORD: prisma\n",
};
var EndpointDialog = /** @class */ (function () {
    function EndpointDialog(out, client, env, config) {
        this.out = out;
        this.client = client;
        this.env = env;
        this.config = config;
    }
    EndpointDialog.prototype.getEndpoint = function () {
        return __awaiter(this, void 0, void 0, function () {
            var localClusterRunning, folderName, loggedIn, clusters, files, hasDockerComposeYml, question, choice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.isClusterOnline('http://localhost:4466')];
                    case 1:
                        localClusterRunning = _a.sent();
                        folderName = path.basename(this.config.definitionDir);
                        return [4 /*yield*/, this.client.isAuthenticated()];
                    case 2:
                        loggedIn = _a.sent();
                        clusters = this.getCloudClusters();
                        files = this.listFiles();
                        hasDockerComposeYml = files.includes('docker-compose.yml');
                        question = this.getClusterQuestion(!loggedIn && !localClusterRunning, hasDockerComposeYml, clusters);
                        return [4 /*yield*/, this.out.prompt(question)];
                    case 3:
                        choice = (_a.sent()).choice;
                        return [2 /*return*/, this.handleChoice({
                                choice: this.decodeName(choice),
                                loggedIn: loggedIn,
                                folderName: folderName,
                                localClusterRunning: localClusterRunning,
                                clusters: clusters,
                            })];
                }
            });
        });
    };
    EndpointDialog.prototype.encodeName = function (name) {
        return encodeMap[name] || name;
    };
    EndpointDialog.prototype.decodeName = function (name) {
        var replaced = name;
        Object.keys(decodeMap).forEach(function (item) {
            if (replaced.includes(item)) {
                replaced = replaced.replace(item, decodeMap[item]);
            }
        });
        return replaced;
    };
    EndpointDialog.prototype.printDatabaseConfig = function (credentials) {
        var defaultDB = JSON.parse(JSON.stringify({
            connector: credentials.type,
            active: !credentials.alreadyData,
            host: credentials.host,
            port: credentials.port || defaultPorts[credentials.type],
            user: credentials.user,
            password: credentials.password,
            database: credentials.database && credentials.database.length > 0
                ? credentials.database
                : undefined,
        }));
        return yaml
            .safeDump({
            databases: {
                default: defaultDB,
            },
        })
            .split('\n')
            .filter(function (l) { return l.trim().length > 0; })
            .map(function (l) { return "        " + l; })
            .join('\n');
    };
    EndpointDialog.prototype.printDatabaseService = function (type) {
        return databaseServiceDefinitions[type];
    };
    EndpointDialog.prototype.handleChoice = function (_a) {
        var choice = _a.choice, loggedIn = _a.loggedIn, folderName = _a.folderName, localClusterRunning = _a.localClusterRunning, _b = _a.clusters, clusters = _b === void 0 ? this.getCloudClusters() : _b;
        return __awaiter(this, void 0, void 0, function () {
            var clusterEndpoint, cluster, workspace, service, stage, credentials, dockerComposeYml, datamodel, _c, type, _d, introspector, schemas, e_1, result_1, _e, _f;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        service = 'default';
                        stage = 'default';
                        dockerComposeYml = util_1.defaultDockerCompose;
                        datamodel = util_1.defaultDataModel;
                        _c = choice;
                        switch (_c) {
                            case 'Use other server': return [3 /*break*/, 1];
                            case 'local': return [3 /*break*/, 3];
                            case 'Create new database': return [3 /*break*/, 3];
                            case 'Use existing database': return [3 /*break*/, 7];
                            case 'sandbox-eu1': return [3 /*break*/, 15];
                            case 'sandbox-us1': return [3 /*break*/, 16];
                        }
                        return [3 /*break*/, 17];
                    case 1: return [4 /*yield*/, this.customEndpointSelector(folderName)];
                    case 2:
                        clusterEndpoint = _g.sent();
                        cluster = new prisma_yml_1.Cluster(this.out, 'custom', clusterEndpoint);
                        return [3 /*break*/, 18];
                    case 3:
                        cluster =
                            (this.env.clusters || []).find(function (c) { return c.name === 'local'; }) ||
                                new prisma_yml_1.Cluster(this.out, 'local', 'http://localhost:4466');
                        if (!(choice === 'Create new database')) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.askForDatabaseType()];
                    case 4:
                        _d = _g.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        _d = 'mysql';
                        _g.label = 6;
                    case 6:
                        type = _d;
                        dockerComposeYml += this.printDatabaseConfig({
                            user: type === 'mysql' ? 'root' : 'prisma',
                            password: 'prisma',
                            type: type,
                            host: 'db',
                            port: defaultPorts[type],
                        });
                        dockerComposeYml += this.printDatabaseService(type);
                        return [3 /*break*/, 18];
                    case 7: return [4 /*yield*/, this.getDatabase()];
                    case 8:
                        credentials = _g.sent();
                        this.out.action.start("Connecting to database");
                        introspector = new prisma_db_introspection_1.Introspector(credentials);
                        schemas = void 0;
                        _g.label = 9;
                    case 9:
                        _g.trys.push([9, 11, , 12]);
                        return [4 /*yield*/, introspector.listSchemas()];
                    case 10:
                        schemas = _g.sent();
                        return [3 /*break*/, 12];
                    case 11:
                        e_1 = _g.sent();
                        throw new Error("Could not connect to database. " + e_1.message);
                    case 12:
                        if (!(schemas && schemas.length > 0)) return [3 /*break*/, 14];
                        return [4 /*yield*/, introspector.introspect(schemas[0])];
                    case 13:
                        datamodel = _g.sent();
                        dockerComposeYml += this.printDatabaseConfig(credentials);
                        _g.label = 14;
                    case 14:
                        this.out.action.stop();
                        cluster = new prisma_yml_1.Cluster(this.out, 'custom', 'http://localhost:4466');
                        return [3 /*break*/, 18];
                    case 15:
                        cluster = this.env.clusters.find(function (c) { return c.name === 'prisma-eu1'; });
                        _g.label = 16;
                    case 16:
                        cluster = this.env.clusters.find(function (c) { return c.name === 'prisma-us1'; });
                        _g.label = 17;
                    case 17:
                        result_1 = this.getClusterAndWorkspaceFromChoice(choice);
                        if (!result_1.workspace) {
                            cluster = clusters.find(function (c) { return c.name === result_1.cluster; });
                            if (!loggedIn && cluster && cluster.shared) {
                                workspace = this.getPublicName();
                            }
                        }
                        else {
                            cluster = clusters.find(function (c) {
                                return c.name === result_1.cluster && c.workspaceSlug === result_1.workspace;
                            });
                            workspace = result_1.workspace;
                        }
                        _g.label = 18;
                    case 18:
                        if (!cluster) {
                            throw new Error("Oops. Could not get cluster.");
                        }
                        this.env.setActiveCluster(cluster);
                        _e = !cluster.local;
                        if (_e) return [3 /*break*/, 20];
                        return [4 /*yield*/, this.projectExists(cluster, service, stage, workspace)];
                    case 19:
                        _e = (_g.sent());
                        _g.label = 20;
                    case 20:
                        if (!_e) return [3 /*break*/, 22];
                        return [4 /*yield*/, this.askForService(folderName)];
                    case 21:
                        service = _g.sent();
                        _g.label = 22;
                    case 22:
                        _f = !cluster.local;
                        if (_f) return [3 /*break*/, 24];
                        return [4 /*yield*/, this.projectExists(cluster, service, stage, workspace)];
                    case 23:
                        _f = (_g.sent());
                        _g.label = 24;
                    case 24:
                        if (!_f) return [3 /*break*/, 26];
                        return [4 /*yield*/, this.askForStage('dev')];
                    case 25:
                        stage = _g.sent();
                        _g.label = 26;
                    case 26: return [2 /*return*/, {
                            endpoint: prisma_yml_1.getEndpoint(cluster, service, stage, workspace),
                            cluster: cluster,
                            workspace: workspace,
                            service: service,
                            stage: stage,
                            localClusterRunning: localClusterRunning,
                            database: credentials,
                            dockerComposeYml: dockerComposeYml,
                            datamodel: datamodel,
                        }];
                }
            });
        });
    };
    EndpointDialog.prototype.getDatabase = function () {
        return __awaiter(this, void 0, void 0, function () {
            var type, host, port, user, password;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.askForDatabaseType()];
                    case 1:
                        type = _a.sent();
                        return [4 /*yield*/, this.ask({
                                message: 'Enter database host',
                                key: 'host',
                                defaultValue: 'localhost',
                            })];
                    case 2:
                        host = _a.sent();
                        return [4 /*yield*/, this.ask({
                                message: 'Enter database port',
                                key: 'port',
                                defaultValue: String(defaultPorts[type]),
                            })];
                    case 3:
                        port = _a.sent();
                        return [4 /*yield*/, this.ask({
                                message: 'Enter database user',
                                key: 'user',
                            })];
                    case 4:
                        user = _a.sent();
                        return [4 /*yield*/, this.ask({
                                message: 'Enter database password',
                                key: 'password',
                            })
                            // const database = await this.ask({
                            //   message: 'Enter database name (only needed when you already have data)',
                            //   key: 'database',
                            // })
                            // const alreadyData = await this.ask({
                            //   message: 'Do you already have data in the database? (yes/no)',
                            //   key: 'alreadyData',
                            //   defaultValue: 'no',
                            //   validate: value =>
                            //     ['yes', 'no'].includes(value) ? true : 'Please answer either yes or no',
                            // })
                        ];
                    case 5:
                        password = _a.sent();
                        // const database = await this.ask({
                        //   message: 'Enter database name (only needed when you already have data)',
                        //   key: 'database',
                        // })
                        // const alreadyData = await this.ask({
                        //   message: 'Do you already have data in the database? (yes/no)',
                        //   key: 'alreadyData',
                        //   defaultValue: 'no',
                        //   validate: value =>
                        //     ['yes', 'no'].includes(value) ? true : 'Please answer either yes or no',
                        // })
                        return [2 /*return*/, {
                                type: type,
                                host: host,
                                port: port,
                                user: user,
                                password: password,
                                // database,
                                alreadyData: false,
                            }];
                }
            });
        });
    };
    EndpointDialog.prototype.getClusterAndWorkspaceFromChoice = function (choice) {
        var splitted = choice.split('/');
        var workspace = splitted.length > 1 ? splitted[0] : null;
        var cluster = splitted.slice(-1)[0];
        return { workspace: workspace, cluster: cluster };
    };
    EndpointDialog.prototype.getCloudClusters = function () {
        if (!this.env.clusters) {
            return [];
        }
        return this.env.clusters.filter(function (c) { return c.shared || c.isPrivate; });
    };
    EndpointDialog.prototype.projectExists = function (cluster, name, stage, workspace) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        _a = Boolean;
                        return [4 /*yield*/, this.client.getProject(util_1.concatName(cluster, name, workspace || null), stage)];
                    case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
                    case 2:
                        e_2 = _b.sent();
                        return [2 /*return*/, false];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    EndpointDialog.prototype.listFiles = function () {
        return fs.readdirSync(this.config.definitionDir);
    };
    EndpointDialog.prototype.isClusterOnline = function (endpoint) {
        return __awaiter(this, void 0, void 0, function () {
            var cluster;
            return __generator(this, function (_a) {
                cluster = new prisma_yml_1.Cluster(this.out, 'local', endpoint, undefined, true);
                return [2 /*return*/, cluster.isOnline()];
            });
        });
    };
    EndpointDialog.prototype.getClusterQuestion = function (fromScratch, hasDockerComposeYml, clusters) {
        var _this = this;
        var sandboxChoices = [
            [
                'sandbox-eu1',
                'Free development server on Prisma Cloud (incl. database)',
            ],
            [
                'sandbox-us1',
                'Free development server on Prisma Cloud (incl. database)',
            ],
        ];
        if (fromScratch && !hasDockerComposeYml) {
            var fixChoices = [
                ['Use existing database', 'Connect to existing database'],
                ['Create new database', 'Set up a local database using Docker'],
            ];
            var rawChoices = fixChoices.concat(sandboxChoices);
            var choices = this.convertChoices(rawChoices);
            var finalChoices = [
                new inquirer.Separator('                       '),
                new inquirer.Separator(chalk_1.default.bold('You can set up Prisma  for local development (requires Docker)'))
            ].concat(choices.slice(0, fixChoices.length), [
                new inquirer.Separator('                       '),
                new inquirer.Separator(chalk_1.default.bold('Or use a free hosted Prisma sandbox (includes database)'))
            ], choices.slice(fixChoices.length, 4));
            return {
                name: 'choice',
                type: 'list',
                message: "Connect to your database, set up a new one or use hosted sandbox?",
                choices: finalChoices,
                pageSize: finalChoices.length,
            };
        }
        else {
            var clusterChoices = clusters.length > 0
                ? clusters.map(function (c) { return [
                    "" + (c.workspaceSlug ? c.workspaceSlug + "/" : '') + _this.encodeName(c.name),
                    _this.getClusterDescription(c),
                ]; })
                : sandboxChoices;
            var rawChoices = [
                ['local', 'Local Prisma server (connected to MySQL)']
            ].concat(clusterChoices, [
                ['Use other server', 'Connect to an existing prisma server'],
                ['Use existing database', 'Connect to existing database'],
                ['Create new database', 'Set up a local database using Docker'],
            ]);
            var choices = this.convertChoices(rawChoices);
            var dockerChoices = hasDockerComposeYml
                ? []
                : [
                    new inquirer.Separator(chalk_1.default.bold('Set up a new Prisma server for local development (requires Docker):'))
                ].concat(choices.slice(choices.length - 2));
            var finalChoices = [
                new inquirer.Separator('                       '),
                new inquirer.Separator(chalk_1.default.bold('Use an existing Prisma server'))
            ].concat(choices.slice(0, clusterChoices.length + 2), [
                new inquirer.Separator('                       ')
            ], dockerChoices);
            return {
                name: 'choice',
                type: 'list',
                message: "Connect to your database, set up a new one or use existing Prisma server?",
                choices: finalChoices,
                pageSize: finalChoices.length,
            };
        }
    };
    EndpointDialog.prototype.getClusterDescription = function (c) {
        if (c.shared) {
            return 'Free development server on Prisma Cloud (incl. database)';
        }
        return "Production Prisma cluster";
    };
    EndpointDialog.prototype.askForDatabaseType = function () {
        return __awaiter(this, void 0, void 0, function () {
            var dbType;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.out.prompt({
                            name: 'dbType',
                            type: 'list',
                            message: "What kind of database do you want to deploy to?",
                            choices: [
                                {
                                    value: 'mysql',
                                    name: 'MySQL',
                                },
                                {
                                    value: 'postgres',
                                    name: 'PostgreSQL',
                                },
                            ],
                        })];
                    case 1:
                        dbType = (_a.sent()).dbType;
                        return [2 /*return*/, dbType];
                }
            });
        });
    };
    EndpointDialog.prototype.convertChoices = function (choices) {
        var padded = this.out.printPadded(choices, 0, 6).split('\n');
        return padded.map(function (name, index) { return ({
            name: name,
            value: choices[index][0],
        }); });
    };
    EndpointDialog.prototype.askForStage = function (defaultName) {
        return __awaiter(this, void 0, void 0, function () {
            var question, stage;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        question = {
                            name: 'stage',
                            type: 'input',
                            message: 'To which stage do you want to deploy?',
                            default: defaultName,
                        };
                        return [4 /*yield*/, this.out.prompt(question)];
                    case 1:
                        stage = (_a.sent()).stage;
                        return [2 /*return*/, stage];
                }
            });
        });
    };
    EndpointDialog.prototype.askForService = function (defaultName) {
        return __awaiter(this, void 0, void 0, function () {
            var question, service;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        question = {
                            name: 'service',
                            type: 'input',
                            message: 'How do you want to call your service?',
                            default: defaultName,
                        };
                        return [4 /*yield*/, this.out.prompt(question)];
                    case 1:
                        service = (_a.sent()).service;
                        return [2 /*return*/, service];
                }
            });
        });
    };
    EndpointDialog.prototype.customEndpointSelector = function (defaultName) {
        return __awaiter(this, void 0, void 0, function () {
            var question, endpoint;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        question = {
                            name: 'endpoint',
                            type: 'input',
                            message: "What's your clusters endpoint?",
                            default: defaultName,
                        };
                        return [4 /*yield*/, this.out.prompt(question)];
                    case 1:
                        endpoint = (_a.sent()).endpoint;
                        return [2 /*return*/, endpoint];
                }
            });
        });
    };
    EndpointDialog.prototype.ask = function (_a) {
        var message = _a.message, defaultValue = _a.defaultValue, key = _a.key, validate = _a.validate, required = _a.required;
        return __awaiter(this, void 0, void 0, function () {
            var question, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        question = {
                            name: key,
                            type: 'input',
                            message: message,
                            default: defaultValue,
                            validate: defaultValue || !required
                                ? undefined
                                : validate ||
                                    (function (value) {
                                        return value && value.length > 0
                                            ? true
                                            : "Please provide a valid " + key;
                                    }),
                        };
                        return [4 /*yield*/, this.out.prompt(question)];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, result[key]];
                }
            });
        });
    };
    EndpointDialog.prototype.getSillyName = function () {
        return slugify(sillyname()).split('-')[0] + "-" + Math.round(Math.random() * 1000);
    };
    EndpointDialog.prototype.getPublicName = function () {
        return "public-" + this.getSillyName();
    };
    return EndpointDialog;
}());
exports.EndpointDialog = EndpointDialog;
function slugify(text) {
    return text
        .toString()
        .toLowerCase()
        .replace(/\s+/g, '-') // Replace spaces with -
        .replace(/[^\w\-]+/g, '') // Remove all non-word chars
        .replace(/\-\-+/g, '-') // Replace multiple - with single -
        .replace(/^-+/, '') // Trim - from start of text
        .replace(/-+$/, ''); // Trim - from end of text
}
//# sourceMappingURL=EndpointDialog.js.map